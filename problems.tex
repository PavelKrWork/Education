\documentclass[a4paper,12pt]{article}



\usepackage[export]{adjustbox}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}



\usepackage{amsbsy}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsopn}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amsxtra}
\usepackage{array}
\usepackage{ctable}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{xcolor}



\renewcommand{\familydefault}{\sfdefault}

\renewcommand{\arraystretch}{1.5}

\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\geometry{left   = 0.5cm}
\geometry{bottom = 0.5cm}
\geometry{right  = 0.5cm}
\geometry{top    = 0.5cm}

\parindent = 0pt
\parskip   = 0pt
\tolerance = 100

\flushbottom

\definecolor{G}{rgb}{0.00, 0.50, 0.00}

\hypersetup
{
    linkcolor  = G,
    urlcolor   = G,
    colorlinks = true
}

\renewenvironment{itemize}
{
    \begin{list}{\labelitemi}
    {
      \setlength{\topsep}{0pt}
      \setlength{\partopsep}{0pt}
      \setlength{\parskip}{0pt}
      \setlength{\itemsep}{0pt}
      \setlength{\parsep}{0pt}
      \setlength{\leftmargin}{14.5pt}
    }
}{\end{list}}

\definecolor{B}{rgb}{0.00, 0.00, 0.50}

\lstset
{
    backgroundcolor   = \color{white},      % Установка цвета заднего плана  
    basicstyle        = \ttfamily\color{B}, % Установка размера и цвета шрифта
    breakatwhitespace = true,               % Установка разрывов на пробелах
    breaklines        = true,               % Установка переноса длинных строк
    captionpos        = none,               % Установка позиции имени листинга
    commentstyle      = \color{B},          % Установка цвета комментариев кода
    deletekeywords    = {},                 % Установка удаленных ключевых слов  
    escapeinside      = {\%*}{*)},          % Установка добавления LaTeX в коде  
    extendedchars     = false,              % Установка дополнительных символов 
    frame             = L,                  % Установка типа рамки вокруг кода
    framexleftmargin  = -8pt,               % Установка размера левого отступа
    keepspaces        = true,               % Установка выравнивания пробелов
    keywordstyle      = \color{B},          % Установка цвета ключевых слов  
    language          = C++,                % Установка языка программирования
    otherkeywords     = {},                 % Установка добавочных ключевых слов   
    numbers           = none,               % Установка позиции нумерации строк
    numbersep         = 0pt,                % Установка отступа нумерации строк
    numberstyle       = \color{black},      % Установка цвета нумерации строк
    showspaces        = false,              % Установка пробелов символом '_'
    showstringspaces  = false,              % Установка пробелов символом '_'
    showtabs          = false,              % Установка табуляторов видимыми
    stepnumber        = 1,                  % Установка периода нумерации строк
    stringstyle       = \color{B},          % Установка цвета строковых литералов
    tabsize           = 2,                  % Установка размера табуляции в коде
}



\begin{document}



\newpage\thispagestyle{empty}\pdfpageheight = 2.50in\enlargethispage{100in}

\title{\bf Software Engineering} 

\author{Moscow Institute of Physics and Technology}

\date{}

\maketitle



\newpage\thispagestyle{empty}\pdfpageheight = 6.10in\enlargethispage{100in}

\renewcommand\contentsname{\Large Table of Contents}

\renewcommand{\cftdotsep}{0.5}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\makeatletter
\let\latexl@section\l@section
\def\l@section#1#2{\begingroup\let\numberline\@gobble\latexl@section{#1}{#2}\endgroup}
\makeatother

\titlelabel{}

\thispagestyle{empty}\tableofcontents\thispagestyle{empty}



\newpage\thispagestyle{empty}\pdfpageheight = 4.20in

\textbf{\Large 00. Mandatory Requirements}

\bigskip

\,\textbf{Требования: часть 1}

\medskip

\begin{itemize}

    \item Ваши решения должны собираться без предупреждений с флагами\;-Wall,\;-Wextra\;и\;-Wpedantic.

    \smallskip

    \item Ваши решения должны сопровождаться тестами\:и\:демонстрационными\:примерами.

    \smallskip

    \item Ваши решения должны выполняться\;до\;конца\;и\;проходить\;тесты\;без\;ошибок\;и\;неопределенного\;поведения.

    \smallskip

    \item Ваши решения должны располагаться\;каждое\;в\;отдельном\;единственном\;файле\;исходного\;кода.

    \smallskip

    \item Ваши решения должны быть адекватно отформатированы в рамках единого стиля.
    
\end{itemize}

\bigskip

\,\textbf{Требования: часть 2}

\medskip

\begin{itemize}

    \item Ваши решения не должны содержать символы,\;не\;представленные\;в\;таблице\;семибитного\:стандарта\:ASCII.

    \smallskip

    \item Ваши решения не должны содержать магические\;литералы и непонятные\;названия.

    \smallskip

    \item Ваши решения не должны содержать неинициализированные\,переменные\,и\,глобальные\,объекты.

    \smallskip

    \item Ваши решения не должны содержать дублирующийся код и неиспользуемые части.

    \smallskip

    \item Ваши решения не должны содержать избыточного использования стандартных\,потоков\,для\,ввода\,и\,вывода.

\end{itemize}

\bigskip

\,В случае конфликтов требований в приоритете является выполнение требований, указанных в условиях задач.



\newpage\thispagestyle{empty}\pdfpageheight = 5.20in

\section{01. Introduction and Brief Overview}

{\large \textbf{01.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.07.cpp}{\texttt{06.07}}]}} 

\bigskip

Напишите программу, которая выводит в стандартный символьный поток вывода \lstinline{std::cout} любую строку и при этом обладает функцией \lstinline{main} с единственной инструкцией \lstinline{return 0}. Предложите по крайней мере четыре разных решения. Впервые я столкнулся с этой задачей на техническом собеседовании в крупную российскую компанию. Для ее решения Вам потребуются технологии, которые будут рассматриваться во втором, третьем и шестом модулях данного курса, поэтому Вы можете пропустить эту задачу и вернуться к ней позже. Возможно, Вы немного удивились тому, что первая же задача данного курса обладает настолько неадекватным уровнем сложности. Это своеобразная дань памяти моему детству. Я начал серьезно изучать компьютерные науки и языки программирования в 12 лет, когда проводил летние школьные каникулы на даче у бабушки с дедушкой. Родители подарили мне две книги: Программирование -- принципы и практика с использованием C\texttt{++} Бьёрна Страуструпа и Язык программирования C Брайана Кернигана и Денниса Ритчи. Также у меня имелся простой ноутбук со средой разработки Code::Blocks, однако не было ни интернета, ни даже мобильной связи, потому что дача находится в низине, а сеть можно поймать только на определенном тайном холмике в лесу. Я решил начать изучение с визуально небольшой книги по языку C, быстро проработать ее, а потом приступить к монографии Страуструпа. Опрометчивое решение! В одном из первых заданий просили написать программу, которая удалила бы все комментарии из исходного кода другой программы на языке C. Предположу, что это весьма сложная задача для третьего дня изучения программирования, но я справился, потому что из-за отсутствия связи с внешним миром я просто не понял, что это сложно. Возможно, именно этот случай помог мне определиться с основным направлением всей дальнейшей деятельности. Любопытно, что случилось, если бы мне тогда подарили монографию Искусство программирования Дональда Кнута? Возможно, я стал бы лучше относиться к математике. Пожалуй, стоит провести небольшой эксперимент над собственными детьми.



\newpage\thispagestyle{empty}\pdfpageheight = 17.50in\enlargethispage{100in}

\section{02. Basics of Programming}

{\large \textbf{02.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.12.cpp}{\texttt{02.12}}]}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе формулы Бине. Используйте тип \lstinline{double} для промежуточных вычислений и тип \lstinline{int} для конечного значения числа ряда Фибоначчи. Используйте оператор \lstinline{static_cast} для преобразования округленного приближенного значения формулы Бине типа \lstinline{double} к конечному значению типа \lstinline{int}. Используйте константы для значений в формуле Бине. Используйте стандартные функции \lstinline{std::sqrt}, \lstinline{std::pow} и \lstinline{std::round}. Обоснуйте формулу Бине. Используйте стандарт- ный символьный поток ввода \lstinline{std::cin} для ввода номера N. Используйте стандартный символьный поток вы- 

вода \lstinline{std::cout} для вывода числа ряда Фибоначчи. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.17.cpp}{\texttt{02.17}}]}}

\bigskip

Реализуйте алгоритм вычисления корней алгебраического уравнения второй степени с коэффициентами a, b и c типа \lstinline{double}. Используйте ветвления \lstinline{if} для проверки значения коэффициента a и значения дискриминанта. Используйте константу epsilon и стандартную функцию \lstinline{std::abs} для корректного сравнения чисел типа \lstinline{double} с заданной точностью. Допускайте появление отрицательного нуля. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода коэффициентов a, b и c. Используйте стандартный\,символьный\,по- 

ток вывода \lstinline{std::cout} для вывода корней уравнения. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.18.cpp}{\texttt{02.18}}]}}

\bigskip

Реализуйте алгоритм классификации символов типа \lstinline{char} из таблицы ASCII с десятичными кодами от 32 до 127 включительно на пять следующих классов: заглавные буквы, строчные буквы, десятичные цифры, знаки препинания, прочие символы. Используйте ветвление \lstinline{switch} с проваливанием и символьными литералами типа \lstinline{char} в качестве меток в секциях \lstinline{case}. Протестируйте нестандартное расширение компилятора g\texttt{++} для диапазонов и флаг компилятора -Wpedantic. Используйте секцию \lstinline{default} для пятого класса. Используйте стандартный символьный поток ввода \lstinline{std::cin} для\,ввода\,символов.\,Используйте\,стандартный\,символьный\,по- 

ток вывода \lstinline{std::cout} для вывода названий классов. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.04} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.20.cpp}{\texttt{02.20}}]}}

\bigskip

Реализуйте алгоритм вычисления всех трехзначных чисел Армстронга. Используйте тройной вложенный цикл \lstinline{for} для перебора. Не используйте стандартную функцию \lstinline{std::pow}. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода чисел Армстронга. Не\:сопровождайте\:Ваше\:решение\:данной\:задачи\:тестами.

\bigskip

{\large \textbf{02.05} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.24.cpp}{\texttt{02.24}}]}}

\bigskip

Реализуйте алгоритм вычисления числа e на основе суммы членов ряда Маклорена при x равном 1 с точностью, заданной числом epsilon. Используйте тип \lstinline{double} для промежуточных вычислений и конечного значения числа e. Не вычисляйте факториалы в знаменателях членов ряда Маклорена, чтобы не столкнуться с проблемой переполнения. Используйте известное соотношение между членами ряда Маклорена для оптимизации вычисления каждого нового члена ряда на основе предыдущего члена ряда. Используйте цикл \lstinline{while} для вычисления членов ряда Маклорена, пока очередной член ряда не станет меньше числа epsilon. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода числа epsilon. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода числа e. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.06} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.29.cpp}{\texttt{02.29}}]}}

\bigskip

Реализуйте алгоритмы вычисления максимального и минимального значений, медианы, среднего арифметического и стандартного отклонения коллекции чисел типа \lstinline{double}. Используйте встроенный статический массив для хранения и обработки коллекции чисел. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода коллекции чисел. Используйте любой удобный для Вас способ ввода коллекции чисел, например, с предварительным вводом размера коллекции чисел. Реализуйте алгоритм сортировки вставками как подготовительную часть алгоритма вычисления медианы коллекции чисел. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода максимального и минимального значений, медианы, среднего арифмети- 

ческого и стандартного отклонения коллекции чисел. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.07} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.30.cpp}{\texttt{02.30}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.06 таким образом, чтобы вместо встроенного статического массива использовался встроенный динамический массив. Предполагайте, что размер коллекции чисел заранее неизвестен. Реализуйте алгоритм увеличения емкости динамического массива. Реализуйте выделение нового блока памяти размером в два раза больше предыдущего блока памяти, копирование в новый блок памяти всех существующих чисел из предыдущего блока памяти и корректное освобождение предыдущего блока памяти.

\bigskip

{\large \textbf{02.08} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.31.cpp}{\texttt{02.31}}]}}

\bigskip

Реализуйте алгоритм вычисления наибольшей длины последовательности Коллатца среди всех последовательностей, начинающихся со значений от 1 до 100. Используйте тип \lstinline{unsigned long long int} для значений последовательностей Коллатца и стандартный псевдоним \lstinline{std::size_t} для их длин. Используйте кэширование длин последовательностей Коллатца в стандартном контейнере \lstinline{std::vector} для оптимизации вычисления длины каждой новой последовательности на основе предыдущих последовательностей. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода наибольшей длины последовательности Коллатца среди всех рассмотренных, а также ее начального значения. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.09} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.41.cpp}{\texttt{02.41}}]}}

\bigskip

Реализуйте алгоритмы вычисления наибольшего общего делителя двух натуральных чисел типа \lstinline{int} на основе рекурсивного и итративного подходов, а также алгоритм вычисления наименьшего общего кратного двух натуральных чисел типа \lstinline{int}. Используйте стандартные функции \lstinline{std::gcd} и \lstinline{std::lcm} для валидации результатов.

\bigskip

{\large \textbf{02.10} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{\texttt{02.44}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{\texttt{02.44}} таким образом, чтобы вместо алгоритма сортировки слиянием использовался алгоритм быстрой сортировки. Реализуйте метод Хоара. Используйте медиану первого, среднего и последнего элементов как опорный элемент. Обоснуйте временную сложность полученного\;гибридного\;алгоритма\;сортировки.



\newpage\thispagestyle{empty}\pdfpageheight = 15.20in\enlargethispage{100in}

\section{03. Object\,-\,Oriented Programming}

{\large \textbf{03.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.02.cpp}{\texttt{03.02}}]}}

\bigskip

Реализуйте структуру \lstinline{Rectangle} для представления прямоугольников со сторонами, которые параллельны осям координатной плоскости. Реализуйте в структуре \lstinline{Rectangle} поля типа \lstinline{double} для хранения координат левого верхнего и правого нижнего углов прямоугольника. Используйте систему координат, в которой ось абсцисс направлена вправо, а ось ординат направлена вниз. Реализуйте алгоритм вычисления площади пересечения нескольких прямоугольников как свободную функцию. Рассмотрите случаи вырожденного\,и\,пустого\,пе- 

ресечения. Реализуйте алгоритм вычисления минимального ограничивающего прямоугольника как свободную функцию. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров структуры \lstinline{Rectangle}.

\bigskip

{\large \textbf{03.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.04.cpp}{\texttt{03.04}}]}}

\bigskip

Реализуйте класс \lstinline{Triangle} для представления треугольников. Реализуйте в классе \lstinline{Triangle} три поля типа \lstinline{double} для хранения длин трех сторон. Реализуйте класс \lstinline{Square} для представления квадратов. Реализуйте в классе \lstinline{Square} одно поле типа \lstinline{double} для хранения длины одной стороны. Реализуйте класс \lstinline{Circle} для представления окружностей. Реализуйте в классе \lstinline{Circle} одно поле типа \lstinline{double} для хранения радиуса. Реализуйте алгоритмы вычисления периметра и площади для всех указанных фигур как публичные функции- члены соответствующих классов. Используйте стандартную константу \lstinline{std::numbers::pi} для класса \lstinline{Circle}.

\bigskip

{\large \textbf{03.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.05.cpp}{\texttt{03.05}}]}}

\bigskip

Реализуйте класс \lstinline{List} для представления односвязного списка. Реализуйте структуру \lstinline{Node} для представления узлов односвязного списка как приватную вложенную структуру в классе \lstinline{List}. Реализуйте в структуре \lstinline{Node} поле типа \lstinline{int} для хранения значения текущего узла списка и поле типа \lstinline{Node *} для хранения адреса следующего узла списка. Реализуйте в классе \lstinline{List} два приватных поля типа \lstinline{Node *} для хранения адресов головного и хвостового узлов списка. Не создавайте в классе \lstinline{List} поле для хранения текущей длины списка и пользовательские конструкторы. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{empty} для проверки наличия узлов в списке. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{show} для вывода в стандартный символьный поток вывода \lstinline{std::cout} значений всех текущих узлов списка. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{push_front} и \lstinline{push_back} для добавления новых узлов в начало и в конец списка соответственно. Используйте оператор \lstinline{new} для динамического выделения памяти. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{pop_front} и \lstinline{pop_back} для удаления узлов из начала и из конца списка соответственно. Используйте оператор \lstinline{delete} для освобождения памяти. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{get} для получения значения текущего среднего узла списка. Используйте только один цикл для обхода списка в функции-члене \lstinline{get}. Реализуйте деструктор, который корректно освободит память, выделенную при создании 

узлов списка. Выполните модульное и интеграционное тестирование для всех реализованных функций-членов.

\bigskip

{\large \textbf{03.04} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.09.cpp}{\texttt{03.09}}]}}

\bigskip

Реализуйте систему внешнего тестирования приватных функций-членов некоторого класса. Реализуйте класс \lstinline{Entity}. Реализуйте в классе \lstinline{Entity} две демонстрационные приватные функции-члены, которые необходимо будет подвергнуть тестированию. Вспомните о принципе SOLID единственности ответственности. Реализуйте два дополнительных самостоятельных класса-тестировщика, каждый из которых будет предназначен для тестирования одной соответствующей ему приватной функции-члена класса \lstinline{Entity}. Используйте отношение дружбы между классами-тестировщиками и классом \lstinline{Entity}, чтобы выполнить тестирование приватных функций-членов класса \lstinline{Entity} без необходимости обращения к его публичному интерфейсу. Используйте паттерн Attorney\,-\,Client для ограничения доступа классов-тестировщиков к приватной секции класса \lstinline{Entity}.

\bigskip

{\large \textbf{03.05} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.16.cpp}{\texttt{03.16}}]}}

\bigskip

Реализуйте систему раздельного переопределения наследуемых виртуальных функций-членов с одинаковыми сигнатурами. Реализуйте базовые классы \lstinline{Entity_v1} и \lstinline{Entity_v2}. Реализуйте в классе \lstinline{Entity_v1} виртуальную функцию-член \lstinline{test}. Реализуйте в классе \lstinline{Entity_v2} виртуальную функцию-член \lstinline{test}, сигнатура которой полностью совпадает с сигнатурой виртуальной функции-члена \lstinline{test} из класса \lstinline{Entity_v1}. Реализуйте производный класс \lstinline{Client}, который является наследником интерфейсов классов \lstinline{Entity_v1} и \lstinline{Entity_v2}. Обратите внимание, что раздельное переопределение наследуемых виртуальных функций-членов \lstinline{test} в классе \lstinline{Client} невозможно из-за совпадения их сигнатур. Реализуйте дополнительный промежуточный класс \lstinline{Adapter_v1} в иерархии наследования между классами \lstinline{Entity_v1} и \lstinline{Client}. Реализуйте дополнительный промежуточный класс \lstinline{Adapter_v2} в иерархии наследования между классами \lstinline{Entity_v2} и \lstinline{Client}. Реализуйте дополнительные чисто виртуальные функции-члены в классах \lstinline{Adapter_v1} и \lstinline{Adapter_v2}, которые будут обладать разными сигнатурами и предотвратят совпадение сигнатур наследуемых виртуальных функций-членов в классе \lstinline{Client}.

\bigskip

{\large \textbf{03.06} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.17.cpp}{\texttt{03.17}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.02 таким образом, чтобы все реализованные классы принадлежали одной иерархии классов. Реализуйте абстрактный базовый класс \lstinline{Shape} для представления интерфейса использования геометрических фигур. Реализуйте в классе \lstinline{Shape} виртуальный деструктор и чисто виртуальные функции-члены для вычисления периметра и площади. Реализуйте производные классы \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle}, которые являются наследниками интерфейса класса \lstinline{Shape}. Используйте спецификатор \lstinline{override} при переопределении наследуемых чисто виртуальных функций-членов в классах \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle}. Используйте спецификатор \lstinline{final} для запрета наследования или переопределения наследуемых чисто виртуальных функций-членов. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров классов \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle} через указатели на класс \lstinline{Shape}. Продемонстрируйте динамический полиморфизм.



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{04. Generic Programming}



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{05. Software Architecture Patterns}



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{06. Projects and Libraries}



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{07. Handling Errors and Debugging}



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{08. Instruments of Calculus}

{\large \textbf{08.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.02.cpp}{\texttt{08.02}}]}}

\bigskip

Реализуйте алгоритмы вычисления целой части двоичного логарифма положительных чисел типа \lstinline{int} и типа \lstinline{float}. Предполагайте, что оба этих типа имеют размер 4 байта. Используйте значения типа \lstinline{unsigned int} для выполнения побитовых операций. Используйте оператор \lstinline{static_cast} для явного преобразования числа типа \lstinline{int} к значению типа \lstinline{unsigned int} и объединение \lstinline{union} для явного преобразования числа типа \lstinline{float} к значению типа \lstinline{unsigned int}. Используйте цикл \lstinline{while} и оператор побитового сдвига вправо для поиска старшего ненулевого бита в значении типа \lstinline{unsigned int}. Рассматривайте представление числа типа \lstinline{float} в соответствии со стандартом IEEE 754. Рассматривайте как нормализованные, так и денормализованные числа типа \lstinline{float}. Учитывайте, что экспонента числа типа \lstinline{float} имеет смещение на 127, которое обеспечивает хранение отрицательных степеней без знакового бита. Учитывайте, что максимальное значение экспоненты числа типа \lstinline{float} используется для представления значения бесконечности inf и неопределенного значения\,nan.

\bigskip

{\large \textbf{08.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.05.cpp}{\texttt{08.05}}]}}

\bigskip

Сформулируйте способ хранения полухода шахматной партии с минимально возможными затратами памяти.

\bigskip

{\large \textbf{08.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.27.cpp}{\texttt{08.27}}]}}

\bigskip

Реализуйте алгоритм эволюции Ричарда Докинза, описанный им в третьей главе книги Слепой часовщик. Сгенерируйте начальную строку из 23 случайных букв. Сгенерируйте 100 копий начальной строки, заменяя каждую букву начальной строки другой случайной буквой с вероятностью 0.05. Вычислите для каждой из 100 сгенерированных строк значение метрики, показывающей посимвольное расхождение сгенерированной строки и целевой строкой methinksitislikeaweasel. Завершите работу алгоритма, если для любой из 100 сгенерированных строк значение метрики оказалось равным 0, в противном случае выберите любую сгенерированную строку с наименьшим значением метрики в качестве новой начальной строки и повторите итерацию алгоритма. Используйте только строчные буквы английского алфавита. Используйте\;стандартный\;символьный\;поток\;вы- 

вода \lstinline{std::cout} для вывода начальных строк на каждой итерации алгоритма, а также конечной целевой строки.





\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{09. Detailed Memory Management}

{\large \textbf{09.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.01.cpp}{\texttt{09.01}}]}}

\bigskip

Реализуйте класс \lstinline{Tracer} для трассировки вызовов функций. Используйте паттерн RAII для вывода парных сообщений в конструкторе и деструкторе класса \lstinline{Tracer}. Предполагайте, что пользователь самостоятельно создает экземпляр класса \lstinline{Tracer} в начале каждой собственной функции. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода сообщений. Используйте стандартную утилиту \lstinline{std::source_location} для вывода дополнительной информации в сообщениях. Реализуйте функциональный макрос \lstinline{trace} по типу функционального макроса \lstinline{assert} с возможностью отключения трассировки при определении макроса \lstinline{NDEBUG}.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{10. Collections and Containers}

{\large \textbf{10.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.29.cpp}{\texttt{10.29}}]}}

\bigskip

Реализуйте алгоритм моделирования игры Жизнь по стандартным правилам на игровом поле размером 10 на 10 клеток. Задайте начальное состояние игрового поля случайным образом. Используйте стандартный двумерный контейнер \lstinline{std::vector} для хранения текущего состояния игрового поля.\:Используйте\:стандартный\:сим- 

вольный поток вывода \lstinline{std::cout} для вывода состояния игрового поля на каждой итерации моделирования.

\bigskip

{\large \textbf{10.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.33.cpp}{\texttt{10.33}}]}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе метода матричной экспоненциации. Используйте тип \lstinline{boost::numeric::ublas::matrix} для осуществления вычислений с матрицами. Реализуйте алгоритм быстрого возведения начальной матрицы в степень N. Используйте тип \lstinline{usigned long long int} для значений элементов матриц. Обоснуйте алгоритмическую сложность реализованного алгоритма и сравните ее с алгоритмической сложностью других известных Вам алгоритмов вычисления N\,-\,ого числа ряда Фибоначчи.



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{11. Iterators and Algorithm Libraries}

{\large \textbf{11.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.01.cpp}{\texttt{11.01}}]}}

\bigskip

Реализуйте функцию, которая возвращает указатель на саму себя так, чтобы можно было написать следующее: \lstinline{Wrapper function = test(); (*function)();} Используйте класс с перегруженным оператором приведения.

\bigskip

{\large \textbf{11.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.08.cpp}{\texttt{11.08}}]}}

\bigskip

Сравните среднее время вызова лямбда\,-\,функции, сохраненной в переменной с местозаменителем типа \lstinline{auto}, и среднее время вызова той же самой лямбда\,-\,функции, сохраненной в стандартной оболочке \lstinline{std::function}.

\bigskip

{\large \textbf{11.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.27.cpp}{\texttt{11.27}}]}}

\bigskip

Реализуйте алгоритм решения задачи коммивояжера для полносвязного графа, содержащего 10 вершин. Используйте тип \lstinline{int} для значений весов ребер графа. Инициализируйте веса всех ребер графа случайными значениями от 1 до 10. Используйте стандартный двумерный контейнер \lstinline{std::vector} в качестве симметричной относительно главной диагонали матрицы инцидентности для хранения весов ребер графа. Используйте стандартный алгоритм \lstinline{std::next_permutation} для перебора всех перестановок последовательности обхода вершин, включающей в себя каждую вершину графа только один раз. Учтите, что обход вершин графа должен завершаться в начальной вершине. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода матрицы инцидентности, оптимальной последовательности обхода вершин и ее суммарной стоимости.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{12. Text Data Processing}

{\large \textbf{12.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/12.02.cpp}{\texttt{12.02}}]}}

\bigskip

Напишите программу, которая выводит собственный исходный код в стандартный символьный поток вывода \lstinline{std::cout}. Не используйте файловые потоки ввода. Предполагайте, что файл с исходным кодом недоступен.



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{13. Streams and Data Serialization}



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{14. Concurrent Programming}

{\large \textbf{14.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{\texttt{14.09}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{\texttt{14.09}} таким образом, чтобы алгоритм вместо сложения элементов коллекции применял переданное пользователем действие к каждому элементу коллекции. Сравните тип возвращаемого результата реализованного алгоритма с типом возвращаемого результата стандартного последовательного алгоритма \lstinline{std::for_each} без политики выполнения. Обоснуйте различия процессов выполнения этих двух алгоритмов.

\bigskip

{\large \textbf{14.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.10.cpp}{\texttt{14.10}}]}}

\bigskip

Реализуйте систему обработки исключений, которые могут быть выброшены функциями, выполняемыми в дополнительных стандартных потоках \lstinline{std::thread}. Используйте обработчик \lstinline{catch} для перехвата всех исключений в функции дополнительного потока. Используйте стандартный указатель \lstinline{std::exception_ptr} для хранения исключения, который будет доступен в функции дополнительного потока и в функции основного потока. Используйте стандартную функцию \lstinline{std::current_exception} для получения указателя на текущее исключение в функции дополнительного потока. Используйте функцию \lstinline{std::rethrow_exception} для повторной генерации, перехвата и обработки сохраненного через указатель исключения в функции основного потока.

\bigskip

{\large \textbf{14.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.10.cpp}{\texttt{14.10}}]}}

\bigskip





\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{15. Network Technologies and Tools}

{\large \textbf{15.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.01.cpp}{\texttt{15.01}}]}}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Цезаря со сдвигом вправо на заданное количество символов. Предполагайте, что все строки состоят из строчных букв английского алфавита.

\bigskip

{\large \textbf{15.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.02.cpp}{\texttt{15.02}}]}}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Виженера. Предполагайте, что все строки состоят из строчных букв английского алфавита. Реализуйте алгоритм генерации таблицы Виженера на этапе компиляции. Используйте мгновенную функцию со спецификатором \lstinline{consteval} и двумерный стан- дартный контейнер \lstinline{std::array} со спецификатором \lstinline{constexpr} для генерации и хранения таблицы Виженера.  

\end{document}